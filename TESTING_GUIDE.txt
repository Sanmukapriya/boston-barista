BOSTON BARISTA - JEST TESTING GUIDE
=====================================

This guide explains everything about the Jest testing setup I created for your project.

WHAT IS JEST?
=============
Jest is a JavaScript testing framework that helps you write and run tests for your React applications.
It's like having a robot that checks if your code works correctly.

WHAT DID I DO?
==============
1. Created a new git branch called "test/jest-setup"
2. Installed Jest and testing libraries
3. Set up configuration files
4. Wrote tests for your Redux slice and CheckoutForm component
5. Made sure all tests pass

WHY DID I DO THIS?
==================
- To catch bugs before users find them
- To make sure your code works when you make changes
- To document how your code should behave
- To make development faster and safer

INSTALLED PACKAGES EXPLAINED
============================
Here's what each package does:

1. jest - The main testing framework
2. @testing-library/react - Tools to test React components
3. @testing-library/jest-dom - Extra matchers for DOM testing
4. @testing-library/user-event - Simulate user interactions
5. babel-jest - Transforms your code so Jest can understand it
6. @babel/preset-env - Transforms modern JavaScript
7. @babel/preset-react - Transforms React JSX
8. jest-environment-jsdom - Simulates a browser environment
9. whatwg-fetch - Adds fetch API for testing
10. identity-obj-proxy - Mocks CSS modules

CONFIGURATION FILES EXPLAINED
=============================

1. jest.config.cjs
------------------
This tells Jest how to run your tests:
- testEnvironment: 'jsdom' - Creates a fake browser
- setupFilesAfterEnv - Runs setup before each test
- moduleNameMapper - Maps file types to mock objects
- transform - Uses Babel to transform files

2. babel.config.cjs
-------------------
This tells Babel how to transform your code:
- Transforms modern JavaScript to older JavaScript
- Transforms React JSX to regular JavaScript

3. jest.setup.js
----------------
This runs before every test and adds:
- TextEncoder/TextDecoder for react-router
- matchMedia for antd components
- ResizeObserver for antd components

4. test/__mocks__/fileMock.js
-----------------------------
This mocks image files and other assets during testing.

TEST FILES EXPLAINED
====================

1. test/checkoutSlice.test.jsx
-----------------------------
Tests your Redux slice (the data management part):

What it tests:
- Initial state is correct
- setProductDetails works
- setQuantity updates price correctly
- setModifiedPrice calculates correctly
- setCheckoutDetails saves data

How it works:
- Creates a fake state
- Calls Redux actions
- Checks if the state changed correctly

2. test/CheckoutForm.test.jsx
-----------------------------
Tests your checkout form component:

What it tests:
- Form renders with correct values
- Quantity changes update price
- Form submission triggers API calls

How it works:
- Renders the component with fake data
- Simulates user interactions
- Checks if the right things happen

MOCKING EXPLAINED
=================
Mocking means replacing real things with fake versions during testing:

1. react-router-dom - Mocked to avoid routing issues
2. emailjs-com - Mocked to avoid sending real emails
3. antd Select - Mocked as simple HTML select for easier testing
4. fetch - Mocked to avoid real API calls
5. window.location.assign - Avoided browser navigation issues

HOW TO RUN TESTS
================
1. Run all tests: npm test
2. Run tests in watch mode: npm run test:watch
3. Run specific test file: npm test CheckoutForm.test.jsx

HOW TO WRITE NEW TESTS
======================

1. CREATE A TEST FILE
----------------------
Create a new file in the "test" folder ending with ".test.jsx"

Example: test/MyComponent.test.jsx

2. BASIC TEST STRUCTURE
-----------------------
import { render, screen } from '@testing-library/react';
import MyComponent from '../src/components/MyComponent';

describe('MyComponent', () => {
  it('should render correctly', () => {
    render(<MyComponent />);
    expect(screen.getByText('Hello')).toBeInTheDocument();
  });
});

3. TESTING WITH REDUX
---------------------
If your component uses Redux:

import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import myReducer from '../src/redux/slices/mySlice';

function renderWithStore(ui, { preloadedState } = {}) {
  const store = configureStore({ 
    reducer: { mySlice: myReducer }, 
    preloadedState 
  });
  return render(<Provider store={store}>{ui}</Provider>);
}

describe('MyComponent', () => {
  it('should work with Redux', () => {
    const preloadedState = {
      mySlice: { data: 'test' }
    };
    renderWithStore(<MyComponent />, { preloadedState });
    expect(screen.getByText('test')).toBeInTheDocument();
  });
});

4. TESTING USER INTERACTIONS
-----------------------------
import { fireEvent } from '@testing-library/react';

it('should handle button clicks', () => {
  render(<MyComponent />);
  const button = screen.getByRole('button');
  fireEvent.click(button);
  expect(screen.getByText('Clicked!')).toBeInTheDocument();
});

5. TESTING ASYNC OPERATIONS
---------------------------
import { waitFor } from '@testing-library/react';

it('should handle async operations', async () => {
  render(<MyComponent />);
  fireEvent.click(screen.getByRole('button'));
  
  await waitFor(() => {
    expect(screen.getByText('Loaded!')).toBeInTheDocument();
  });
});

COMMON TESTING PATTERNS
========================

1. TESTING COMPONENT RENDERING
-------------------------------
- Check if elements are present
- Check if text content is correct
- Check if attributes are set correctly

2. TESTING USER INPUT
---------------------
- Simulate typing in inputs
- Simulate selecting options
- Check if state updates correctly

3. TESTING FORM SUBMISSION
---------------------------
- Fill out form fields
- Submit the form
- Check if correct API calls are made
- Check if success/error messages appear

4. TESTING REDUX ACTIONS
------------------------
- Dispatch actions
- Check if state changes correctly
- Check if side effects happen

5. TESTING ERROR HANDLING
-------------------------
- Simulate error conditions
- Check if error messages appear
- Check if fallback behavior works

MOCKING STRATEGIES
==================

1. MOCK EXTERNAL LIBRARIES
---------------------------
jest.mock('library-name', () => ({
  functionName: jest.fn()
}));

2. MOCK API CALLS
------------------
global.fetch = jest.fn().mockResolvedValue({
  json: async () => ({ data: 'test' })
});

3. MOCK BROWSER APIs
--------------------
Object.defineProperty(window, 'location', {
  value: { assign: jest.fn() }
});

4. MOCK CSS MODULES
-------------------
Already handled by identity-obj-proxy in jest.config.cjs

TESTING BEST PRACTICES
======================

1. TEST BEHAVIOR, NOT IMPLEMENTATION
------------------------------------
- Test what the user sees and does
- Don't test internal implementation details
- Focus on user interactions

2. WRITE DESCRIPTIVE TEST NAMES
-------------------------------
- Use "should" or "when" in test names
- Be specific about what you're testing
- Example: "should display error message when API fails"

3. ARRANGE, ACT, ASSERT
-----------------------
- Arrange: Set up test data
- Act: Perform the action
- Assert: Check the result

4. ONE ASSERTION PER TEST
------------------------
- Each test should check one thing
- Makes tests easier to understand
- Makes failures easier to debug

5. USE MEANINGFUL DATA
----------------------
- Use realistic test data
- Avoid magic numbers
- Use descriptive variable names

COMMON TESTING COMMANDS
========================

1. FIND ELEMENTS
-----------------
- getByText('text') - Find by text content
- getByRole('button') - Find by accessibility role
- getByPlaceholderText('placeholder') - Find by placeholder
- getByTestId('test-id') - Find by test ID

2. SIMULATE EVENTS
-------------------
- fireEvent.click(element) - Click an element
- fireEvent.change(input, { target: { value: 'text' } }) - Type in input
- fireEvent.submit(form) - Submit a form

3. ASSERTIONS
--------------
- toBeInTheDocument() - Element exists
- toHaveValue('text') - Input has value
- toHaveTextContent('text') - Element contains text
- toHaveBeenCalled() - Function was called
- toHaveBeenCalledWith(args) - Function called with specific args

DEBUGGING TESTS
===============

1. USE screen.debug()
---------------------
Add screen.debug() in your test to see the rendered HTML

2. USE console.log()
--------------------
Add console.log() to see values during tests

3. RUN SINGLE TEST
-------------------
Use .only to run just one test:
it.only('should work', () => { ... });

4. SKIP TESTS
--------------
Use .skip to skip a test:
it.skip('should work', () => { ... });

TROUBLESHOOTING COMMON ISSUES
=============================

1. "Cannot find module" errors
-------------------------------
- Check file paths are correct
- Make sure files exist
- Check import/export syntax

2. "Element not found" errors
-----------------------------
- Use screen.debug() to see what's rendered
- Check if element is actually in the DOM
- Wait for async operations with waitFor()

3. "Act" warnings
------------------
- Wrap state updates in act()
- Use waitFor() for async operations
- Use userEvent instead of fireEvent for complex interactions

4. Redux store errors
---------------------
- Make sure Provider wraps your component
- Check reducer names match
- Verify preloadedState structure

5. CSS module errors
--------------------
- Check jest.config.cjs has identity-obj-proxy
- Verify moduleNameMapper configuration

HOW TO ADD TESTS FOR NEW COMPONENTS
===================================

1. CREATE THE TEST FILE
-----------------------
Create: test/MyNewComponent.test.jsx

2. IMPORT WHAT YOU NEED
-----------------------
import { render, screen, fireEvent } from '@testing-library/react';
import MyNewComponent from '../src/components/MyNewComponent';

3. WRITE YOUR FIRST TEST
------------------------
describe('MyNewComponent', () => {
  it('should render without crashing', () => {
    render(<MyNewComponent />);
    expect(screen.getByText('Expected Text')).toBeInTheDocument();
  });
});

4. ADD MORE TESTS
-----------------
- Test different props
- Test user interactions
- Test error states
- Test loading states

5. RUN YOUR TESTS
-----------------
npm test MyNewComponent.test.jsx

EXAMPLE: TESTING A SIMPLE COMPONENT
===================================

Let's say you have a Button component:

// src/components/Button.jsx
const Button = ({ onClick, children, disabled = false }) => (
  <button onClick={onClick} disabled={disabled}>
    {children}
  </button>
);

// test/Button.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import Button from '../src/components/Button';

describe('Button', () => {
  it('should render button text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('should call onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('should be disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});

EXAMPLE: TESTING A FORM COMPONENT
=================================

// src/components/LoginForm.jsx
const LoginForm = ({ onSubmit }) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit({ email, password });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
};

// test/LoginForm.test.jsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import LoginForm from '../src/components/LoginForm';

describe('LoginForm', () => {
  it('should render form fields', () => {
    render(<LoginForm />);
    expect(screen.getByPlaceholderText('Email')).toBeInTheDocument();
    expect(screen.getByPlaceholderText('Password')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Login' })).toBeInTheDocument();
  });

  it('should update input values when typing', () => {
    render(<LoginForm />);
    
    const emailInput = screen.getByPlaceholderText('Email');
    const passwordInput = screen.getByPlaceholderText('Password');
    
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } });
    fireEvent.change(passwordInput, { target: { value: 'password123' } });
    
    expect(emailInput).toHaveValue('test@example.com');
    expect(passwordInput).toHaveValue('password123');
  });

  it('should call onSubmit with form data when submitted', async () => {
    const handleSubmit = jest.fn();
    render(<LoginForm onSubmit={handleSubmit} />);
    
    fireEvent.change(screen.getByPlaceholderText('Email'), { 
      target: { value: 'test@example.com' } 
    });
    fireEvent.change(screen.getByPlaceholderText('Password'), { 
      target: { value: 'password123' } 
    });
    
    fireEvent.click(screen.getByRole('button', { name: 'Login' }));
    
    await waitFor(() => {
      expect(handleSubmit).toHaveBeenCalledWith({
        email: 'test@example.com',
        password: 'password123'
      });
    });
  });
});

FINAL NOTES
===========

1. Start simple - Test basic rendering first
2. Add complexity gradually - Test interactions, then async operations
3. Test the happy path first - Then add error cases
4. Keep tests focused - One test, one behavior
5. Use descriptive names - Make tests self-documenting
6. Don't test implementation details - Test user behavior
7. Mock external dependencies - Keep tests fast and reliable
8. Run tests frequently - Catch bugs early

Remember: The goal is to catch bugs before users do, not to achieve 100% test coverage. Focus on testing the most important and risky parts of your application.

Happy testing! ðŸ§ª
